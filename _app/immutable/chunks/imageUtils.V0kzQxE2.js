import{b as x}from"./paths.CZHKt0kD.js";function E(t,e){const o=[],r=Math.floor(t.length/e),s=t.length-r*e;for(let n=0;n<e;n++)o[n]=t.slice(n*r,n*r+r),n<s&&o[n].push(t.at(-(n+1)));return o}const R=""+new URL("../workers/basis-ClX4h8Ff.js",import.meta.url).href;async function P(t,e,o=()=>{}){const r=`${x}/basis_encoder.js`,s=await fetch(r);if(!s.ok)throw new Error(`[imageToBasis] | Could not fetch basis_encoder.js.
Fetched url: ${r}
Response Status: ${s.status}`);const n=await s.text(),c=await Promise.all(t.map(h=>new Promise(l=>{k(h.image).then(i=>{l({name:h.name,image:i})})})));return new Promise((h,l)=>{const i=[],a=Array.from({length:e}).map(()=>new Worker(R,{type:"classic"})),u=E(c,e);let w=0;for(let d=0;d<a.length;d++){const b=a[d],p=u[d];b.addEventListener("message",f=>{if(f.data.status==="error"){l(new Error(f.data.reason));return}if(w++,o(w/c.length,w,c.length),i.push({name:f.data.name,file:f.data.data}),w===c.length){h(i);for(const g of a)g.terminate()}});const v={mode:"encode",basisEncoderJS:n,data:p};b.postMessage(v)}})}async function j(t,e=2,o=()=>{}){const r=`${x}/basis_encoder.js`,s=await fetch(r);if(!s.ok)throw new Error(`[basisToImage] | Could not fetch basis_encoder.js.
Fetched url: ${r}
Response Status: ${s.status}`);const n=await s.text();return new Promise((c,h)=>{const l=Array.from({length:e}).map(()=>new Worker(R,{type:"classic"})),i=E(t,e),a={tileWidth:0,tileHeight:0,tiles:[]};let u=0;for(let w=0;w<e;w++){const d=l[w],b=new OffscreenCanvas(0,0),p=i[w];d.addEventListener("message",f=>{const g=f.data;if(g.status==="error"){h(new Error(g.reason));return}const m=new Image;m.onload=()=>{u++,a.tileWidth=m.width,a.tileHeight=m.height;const C=g.name.split(/_|@/g);if(a.tiles.push({x:parseInt(C[1]),y:parseInt(C[2]),image:m}),URL.revokeObjectURL(g.blobURL),o(u/t.length,u,t.length),u===t.length){for(const L of l)L.terminate();c(a)}},m.src=g.blobURL});const v={mode:"transcode",data:p,canvas:b,basisEncoderJS:n};d.postMessage(v,[b])}})}function y(t,e,o){return new Promise((r,s)=>{const n=document.createElement("canvas"),c=n.getContext("2d");if(c===null){s(new Error("[resizeImage] | Could not get 2D Canvas Rendering Context"));return}const h=e.type==="scale"?t.width*e.x:e.type==="additive"?t.width+e.x:e.x,l=e.type==="scale"?t.height*e.y:e.type==="additive"?t.height+e.y:e.y;n.width=h,n.height=l,c.drawImage(t,0,0,n.width,n.height),n.toBlob(i=>{if(i===null){s(new Error("[imageResize] | Could not turn canvas into blob"));return}const a=URL.createObjectURL(i),u=new Image;u.onload=()=>{o==="image"&&r(t)},u.src=a,o==="url"&&r(a)})})}function k(t){return new Promise((e,o)=>{I(t).toBlob(s=>{if(s===null){o(new Error("[imageToBlob] | Could not turn canvas into blob"));return}e(s)})})}async function S(t,e,o,r=()=>{}){const s=[],n=t.width/e,c=t.height/o,h=e*o;let l=0;for(let i=0;i<e;i++)for(let a=0;a<o;a++)s.push(new Promise((u,w)=>{const d=document.createElement("canvas"),b=d.getContext("2d"),p=n*i,v=c*a;if(d.width=n,d.height=c,b===null)throw new Error("[splitImage] | Could not get 2d canvas rendering context");b.drawImage(t,p,v,n,c,0,0,n,c),d.toBlob(f=>{if(f===null){w(new Error("[splitImage] | Could not turn canvas into blob"));return}const g=URL.createObjectURL(f),m=new Image;m.onload=()=>{l++,r(l/h,l,h),u({x:i,y:a,image:m})},m.src=g})}));return await Promise.all(s)}function _(t){return new Promise(e=>{const o=new Blob([t]),r=URL.createObjectURL(o),s=new Image;s.onload=()=>{e(s)},s.src=r})}function I(t,e){const o=document.createElement("canvas"),r=o.getContext("2d");if(r===null)throw new Error("[ImageUtils | toCanvas] | Could not get 2d canvas rendering context");return o.width=t.width,o.height=t.height,r.drawImage(t,0,0,t.width,t.height),o}export{_ as a,k as b,j as f,y as r,S as s,P as t};
